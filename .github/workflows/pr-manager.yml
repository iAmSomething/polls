name: PR Manager (main)

on:
  pull_request_target:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
  pull_request_review:
    types:
      - submitted
  check_suite:
    types:
      - completed
  status:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write
  checks: read
  statuses: read

concurrency:
  group: pr-manager-main
  cancel-in-progress: true

jobs:
  evaluate-and-merge:
    if: >-
      github.event_name != 'pull_request_target' || github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate main PRs and merge when safe
        id: pr_manager
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const shouldCommentOnSkip = ['pull_request_target', 'pull_request_review'].includes(context.eventName);

            async function wait(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function getPRWithMergeability(number) {
              for (let i = 0; i < 6; i++) {
                const { data } = await github.rest.pulls.get({ owner, repo, pull_number: number });
                if (data.mergeable !== null) {
                  return data;
                }
                await wait(2000);
              }
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              return data;
            }

            async function checksAreGreen(sha) {
              const combined = await github.rest.repos.getCombinedStatusForRef({
                owner,
                repo,
                ref: sha,
              });
              const hasStatus = (combined.data.statuses || []).length > 0;

              const checkRuns = await github.paginate(github.rest.checks.listForRef, {
                owner,
                repo,
                ref: sha,
                per_page: 100,
              });
              const hasCheckRuns = checkRuns.length > 0;

              if (!hasStatus && !hasCheckRuns) {
                return { ok: true };
              }

              if (hasStatus && combined.data.state !== 'success') {
                return {
                  ok: false,
                  code: 'status_not_success',
                  reason: `commit status is ${combined.data.state}`,
                  advice: '필수 status가 완료될 때까지 기다리거나 실패 체크를 수정한 뒤 다시 푸시하세요.',
                };
              }

              const blocking = checkRuns.find(run => {
                if (run.name === 'evaluate-and-merge') return false;
                if (run.status !== 'completed') return true;
                return !['success', 'neutral', 'skipped'].includes(run.conclusion);
              });

              if (blocking) {
                const state = blocking.status === 'completed' ? blocking.conclusion : blocking.status;
                return {
                  ok: false,
                  code: 'check_blocking',
                  reason: `check run \"${blocking.name}\" is ${state}`,
                  advice: `체크 "${blocking.name}" 상태(${state})를 해결한 뒤 다시 푸시하거나 재실행하세요.`,
                };
              }

              return { ok: true };
            }

            async function evaluateAndMaybeMerge(prNumber) {
              const pr = await getPRWithMergeability(prNumber);

              async function leaveSkipComment(reason, advice) {
                if (!shouldCommentOnSkip) return;
                const marker = `<!-- pr-manager-skip:${pr.head.sha} -->`;
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: pr.number,
                  per_page: 100,
                });
                if (comments.some(c => (c.body || '').includes(marker))) return;

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: [
                    'PR Manager가 자동 머지를 보류했습니다.',
                    `- Reason: ${reason}`,
                    ...(advice ? [`- Action: ${advice}`] : []),
                    `- Workflow: ${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`,
                    marker,
                  ].join('\n'),
                });
              }

              function adviceFor(reason) {
                if (reason.startsWith('base is ')) return 'main 대상으로 PR을 다시 생성하세요.';
                if (reason === 'draft PR') return 'PR을 Ready for review로 전환하면 재평가됩니다.';
                if (reason.startsWith('state is ')) return '열린(open) PR에서만 자동 머지됩니다.';
                if (reason.startsWith('mergeable=')) {
                  if (reason.includes('mergeable_state=dirty')) return 'main을 rebase/merge 해서 충돌을 해결한 뒤 다시 푸시하세요.';
                  if (reason.includes('mergeable_state=blocked')) return '브랜치 보호 규칙(필수 체크/규칙)을 충족하세요.';
                  if (reason.includes('mergeable_state=behind')) return '브랜치를 main 최신으로 업데이트한 뒤 다시 푸시하세요.';
                  if (reason.includes('mergeable=null')) return 'GitHub가 머지 가능성 계산을 마칠 때까지 잠시 기다린 뒤 다시 푸시하세요.';
                  return 'PR의 충돌/보호 규칙/브랜치 최신화 상태를 확인 후 다시 푸시하세요.';
                }
                if (reason.startsWith('merge failed:')) return '권한/브랜치 보호 규칙/동시 업데이트 여부를 확인 후 다시 시도하세요.';
                if (reason.startsWith('no merge method')) return 'Repository Settings에서 squash/merge/rebase 중 하나를 활성화하세요.';
                if (reason.startsWith('commit status is ')) return '실패 또는 진행중 status를 해결한 뒤 다시 푸시하세요.';
                if (reason.startsWith('check run \"')) return '실패/진행중 체크를 해결한 뒤 다시 푸시하거나 체크를 재실행하세요.';
                return '보류 사유를 해결한 뒤 다시 푸시하면 자동으로 재평가됩니다.';
              }

              async function skipped(reason, advice = null) {
                await leaveSkipComment(reason, advice || adviceFor(reason));
                return { pr: pr.number, action: 'skipped', reason };
              }

              if (pr.base.ref !== 'main') {
                return await skipped(`base is ${pr.base.ref}`);
              }
              if (pr.state !== 'open') {
                return await skipped(`state is ${pr.state}`);
              }
              if (pr.draft) {
                return await skipped('draft PR');
              }
              if (!pr.mergeable) {
                return await skipped(`mergeable=${pr.mergeable}, mergeable_state=${pr.mergeable_state}`);
              }

              const checks = await checksAreGreen(pr.head.sha);
              if (!checks.ok) {
                return await skipped(checks.reason, checks.advice);
              }

              const repoInfo = await github.rest.repos.get({ owner, repo });
              const merge_method = repoInfo.data.allow_squash_merge
                ? 'squash'
                : repoInfo.data.allow_merge_commit
                  ? 'merge'
                  : repoInfo.data.allow_rebase_merge
                    ? 'rebase'
                    : null;

              if (!merge_method) {
                return await skipped('no merge method is enabled in repository settings');
              }

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method,
                });
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: [
                    'PR Manager가 자동 머지했습니다.',
                    `- Method: \`${merge_method}\``,
                    `- Workflow: ${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`,
                  ].join('\n'),
                });
                return { pr: pr.number, action: 'merged', reason: `merged with ${merge_method}` };
              } catch (error) {
                return await skipped(`merge failed: ${error.message}`);
              }
            }

            let targetPRNumbers = [];

            if (context.eventName === 'pull_request_target' && context.payload.pull_request?.number) {
              targetPRNumbers = [context.payload.pull_request.number];
            } else if (context.eventName === 'pull_request_review' && context.payload.pull_request?.number) {
              targetPRNumbers = [context.payload.pull_request.number];
            } else {
              const prs = await github.paginate(github.rest.pulls.list, {
                owner,
                repo,
                state: 'open',
                base: 'main',
                per_page: 100,
              });
              targetPRNumbers = prs.map(pr => pr.number);
            }

            if (targetPRNumbers.length === 0) {
              core.setOutput('merged_count', '0');
              core.setOutput('merged_payload', '[]');
              await core.summary.addHeading('PR Manager Result').addRaw('No open PRs targeting main.').write();
              return;
            }

            const results = [];
            for (const prNumber of targetPRNumbers) {
              const result = await evaluateAndMaybeMerge(prNumber);
              results.push(result);
            }

            core.summary.addHeading('PR Manager Result');
            for (const r of results) {
              core.summary.addRaw(`- #${r.pr}: ${r.action} (${r.reason})\n`);
            }
            await core.summary.write();

            const merged = results.filter(r => r.action === 'merged');
            core.setOutput('merged_count', String(merged.length));
            core.setOutput('merged_payload', JSON.stringify(merged));

      - name: Notify Slack on merged PRs
        if: steps.pr_manager.outputs.merged_count != '0'
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          MERGED_PAYLOAD: ${{ steps.pr_manager.outputs.merged_payload }}
        with:
          script: |
            if (!process.env.SLACK_WEBHOOK_URL) {
              core.info('SLACK_WEBHOOK_URL not set; skip Slack notification.');
              return;
            }
            const merged = JSON.parse(process.env.MERGED_PAYLOAD || '[]');
            const lines = merged.map(
              r => `• <${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/pull/${r.pr}|#${r.pr}> ${r.reason}`
            );
            const text = [
              `PR Manager: ${merged.length} PR merged to main`,
              ...lines,
              `Run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
            ].join('\n');

            const response = await fetch(process.env.SLACK_WEBHOOK_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text }),
            });

            if (!response.ok) {
              const body = await response.text();
              core.setFailed(`Slack notify failed: ${response.status} ${body}`);
            }

      - name: Trigger dashboard deploy workflow
        if: steps.pr_manager.outputs.merged_count != '0'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'pages.yml',
              ref: 'main',
            });
            core.info('Triggered Build and Deploy Dashboard via workflow_dispatch.');
